#!/usr/bin/env bash
set -euo pipefail

#
# init_cbmc.sh
#
# Initialise CBMC support for all C benchmarks generated by init_c.sh.
# It creates:
#   - cbmc/cbmc_env.h
#   - cbmc/cbmc_env_impl.c
#   - cbmc/run_cbmc_all.sh   (runs CBMC on all c/**/*.c)
#

# Project layout: repo_root / {c,wasm,script,...}
ROOT_DIR="$(cd "$(dirname "${BASH_SOURCE[0]}")/.."; pwd)"
SRC_ROOT="${ROOT_DIR}/c"
CBMC_ROOT="${ROOT_DIR}/cbmc"

mkdir -p "${CBMC_ROOT}"

echo "Project root : ${ROOT_DIR}"
echo "C sources    : ${SRC_ROOT}"
echo "CBMC files   : ${CBMC_ROOT}"
echo

###############################################
# 1) Create cbmc_env.h
###############################################

cat > "${CBMC_ROOT}/cbmc_env.h" <<'EOF'
#ifndef CBMC_ENV_H
#define CBMC_ENV_H

#include <assert.h>

/*
 * CBMC environment for your Wasm-like benchmarks.
 *
 * We model linear memory as a single flat byte array of
 * N_PAGES * WASM_PAGE_SIZE bytes.
 *
 * This header provides:
 *   - WASM_PAGE_SIZE      : 64 KiB
 *   - wasm_pages()        : returns N_PAGES
 *   - wasm_heap_base()    : pointer to start of linear memory
 *   - print_int(int)      : no-op for CBMC
 *
 * Any benchmark that currently relies on:
 *   - __builtin_wasm_memory_size(0)
 *   - __heap_base
 *   - print_int(int)
 * can be made CBMC-friendly by compiling with:
 *
 *   cbmc file.c cbmc_env_impl.c -Icbmc -DCBMC ...
 *
 * and by either:
 *   (a) including cbmc_env.h directly under #ifdef CBMC, or
 *   (b) mapping the Wasm-specific helpers to these stubs.
 */

/* Fixed page size as in WARDuino / WebAssembly. */
#define WASM_PAGE_SIZE 0x10000u  /* 64 KiB */

/* Choose a small number of pages for CBMC's bounded model. */
#ifndef CBMC_N_PAGES
#  define CBMC_N_PAGES 2
#endif

/* Concrete linear memory buffer is defined in cbmc_env_impl.c. */
extern unsigned char __CPROVER_heap_mem[CBMC_N_PAGES * WASM_PAGE_SIZE];

/* Return number of pages (mirrors __builtin_wasm_memory_size(0)). */
static inline int wasm_pages(void) {
    return (int)CBMC_N_PAGES;
}

/* Return a pointer to the start of linear memory. */
static inline unsigned char *wasm_heap_base(void) {
    return __CPROVER_heap_mem;
}

/*
 * If your C code calls __builtin_wasm_memory_size(0) directly,
 * we provide a stub with the same signature.
 */
static inline int __builtin_wasm_memory_size(int idx) {
    (void)idx;
    return (int)CBMC_N_PAGES;
}

/*
 * Some of your benchmarks call extern unsigned char __heap_base[].
 * For CBMC, we treat that as an alias of wasm_heap_base().
 */
extern unsigned char __heap_base[];

static inline unsigned char *cbmc_heap_base_alias(void) {
    return wasm_heap_base();
}

/*
 * Dummy print: CBMC does not care about I/O.
 */
static inline void print_int(int x) {
    (void)x;
}

#endif /* CBMC_ENV_H */
EOF

###############################################
# 2) Create cbmc_env_impl.c
###############################################

cat > "${CBMC_ROOT}/cbmc_env_impl.c" <<'EOF'
#include "cbmc_env.h"

/*
 * Concrete definition of the linear memory buffer for CBMC.
 * CBMC treats this as a statically allocated array; no malloc.
 */
unsigned char __CPROVER_heap_mem[CBMC_N_PAGES * WASM_PAGE_SIZE];

/*
 * Alias symbol for __heap_base, if benchmarks declare:
 *
 *   extern unsigned char __heap_base[];
 *
 * We bind it to the start of our heap model.
 */
unsigned char __heap_base[CBMC_N_PAGES * WASM_PAGE_SIZE];

/*
 * Optionally ensure __heap_base and __CPROVER_heap_mem are consistent.
 * CBMC will track all accesses through both names.
 */
__attribute__((constructor))
static void cbmc_init_heap_alias(void) {
    /* For CBMC this does not need to copy bytes; we simply rely on
       the fact that both are statically allocated arrays of the
       same size. If you want, you can assert equality here. */
    (void)cbmc_init_heap_alias; /* suppress unused warning */
}
EOF

###############################################
# 3) Create run_cbmc_all.sh
###############################################

cat > "${CBMC_ROOT}/run_cbmc_all.sh" <<'EOF'
#!/usr/bin/env bash
set -euo pipefail

# Simple driver to run CBMC on all benchmarks under ../c
# and summarise results in cbmc/results.csv.

SCRIPT_DIR="$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)"
ROOT_DIR="$(cd "${SCRIPT_DIR}/.."; pwd)"
SRC_ROOT="${ROOT_DIR}/c"
CBMC_ROOT="${ROOT_DIR}/cbmc"
OUT_CSV="${CBMC_ROOT}/results.csv"

CBMC_BIN="${CBMC_BIN:-cbmc}"

echo "CBMC root  : ${CBMC_ROOT}"
echo "Source root: ${SRC_ROOT}"
echo "CBMC binary: ${CBMC_BIN}"
echo "Output CSV : ${OUT_CSV}"
echo

mkdir -p "${CBMC_ROOT}/logs"

# CSV header
echo "file,result" > "${OUT_CSV}"

# Collect all .c files under c/, ignoring cbmc_* helpers if any
shopt -s nullglob
cd "${SRC_ROOT}"
c_files=( $(find . -name '*.c' -print | sort) )
cd - >/dev/null
shopt -u nullglob

if [ ${#c_files[@]} -eq 0 ]; then
  echo "No .c files found under ${SRC_ROOT}"
  exit 0
fi

# Temporarily disable "exit on error" inside the loop: we want to
# record both SAFE and UNSAFE results.
set +e

for rel in "${c_files[@]}"; do
  src="${SRC_ROOT}/${rel}"
  rel_clean="${rel#./}"

  log_file="${CBMC_ROOT}/logs/$(echo "${rel_clean}" | tr '/.' '__').log"

  echo "Running CBMC on ${rel_clean} ..."
  echo "  log -> ${log_file}"

  # Run CBMC with:
  #  - include path to cbmc_env.h
  #  - link cbmc_env_impl.c
  #  - entry function 'start'
  #  - pointer / bounds / overflow checks
  "${CBMC_BIN}" \
    "${src}" "${CBMC_ROOT}/cbmc_env_impl.c" \
    -I"${CBMC_ROOT}" \
    -DCBMC \
    --function start \
    --bounds-check \
    --pointer-check \
    --signed-overflow-check \
    --div-by-zero-check \
    --unwind 8 \
    --trace > "${log_file}" 2>&1

  status=$?

  # CBMC exit codes:
  #   0  = verification successful
  #  10  = verification failed (counterexample)
  # others = internal / front-end errors
  result="UNKNOWN"
  if [ "${status}" -eq 0 ]; then
    result="SAFE"
  elif [ "${status}" -eq 10 ]; then
    result="UNSAFE"
  else
    result="ERROR(${status})"
  fi

  echo "  result: ${result}"
  echo "\"${rel_clean}\",\"${result}\"" >> "${OUT_CSV}"
done

set -e

echo
echo "CBMC run complete. Summary in: ${OUT_CSV}"
echo "Individual logs in: ${CBMC_ROOT}/logs"
EOF

chmod +x "${CBMC_ROOT}/run_cbmc_all.sh"

echo "Created:"
echo "  ${CBMC_ROOT}/cbmc_env.h"
echo "  ${CBMC_ROOT}/cbmc_env_impl.c"
echo "  ${CBMC_ROOT}/run_cbmc_all.sh"
echo
echo "Next step: run  cbmc/run_cbmc_all.sh  to analyse all benchmarks."
